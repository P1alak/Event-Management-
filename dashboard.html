<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Event Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h2 { color: #333; }
    form { margin-bottom: 20px; }
    input, select, button { margin: 5px; padding: 8px; }
    .event { border: 1px solid #ccc; padding: 10px; margin: 5px; border-radius: 5px; }
    .completed { text-decoration: line-through; color: gray; }
  </style>
</head>
<body>
  <h2 id="userEmail">Welcome!</h2>
  <button id="logoutBtn">Logout</button>

  <h3>Add Event</h3>
  <form onsubmit="event.preventDefault(); addEvent();">
    <input type="text" id="title" placeholder="Event Title" required>
    <input type="date" id="date" required>
    <select id="priority">
      <option value="normal">Normal</option>
      <option value="urgent">Urgent</option>
    </select>
    <button type="submit">Add Event</button>
  </form>

  <h3>All Events</h3>
  <div id="eventList"></div>

  <h3>Urgent Queue</h3>
  <div id="urgentList"></div>

  <h3>Completed (Undo Stack)</h3>
  <button onclick="undoComplete()">Undo Last Complete</button>
  <div id="completedList"></div>

  <script>
    // Linked List Implementation
    class Node {
      constructor(data){ this.data = data; this.next = null; }
    }
    class LinkedList {
      constructor(){ this.head = null; }
      insert(data){
        const node = new Node(data);
        if(!this.head){ this.head = node; return; }
        let current = this.head;
        while(current.next) current = current.next;
        current.next = node;
      }
      toArray(){
        let arr=[], current=this.head;
        while(current){ arr.push(current.data); current=current.next; }
        return arr;
      }
      delete(id){
        if(!this.head) return;
        if(this.head.data.id===id){ this.head=this.head.next; return; }
        let current=this.head;
        while(current.next && current.next.data.id!==id) current=current.next;
        if(current.next) current.next=current.next.next;
      }
      markComplete(id){
        let current=this.head;
        while(current){ if(current.data.id===id){ current.data.completed=true; return; } current=current.next; }
      }
      undoComplete(id){
        let current=this.head;
        while(current){ if(current.data.id===id){ current.data.completed=false; return; } current=current.next; }
      }
    }

    // Stack (Undo for completed tasks)
    class Stack{
      constructor(){ this.items=[]; }
      push(x){ this.items.push(x); }
      pop(){ return this.items.pop(); }
      isEmpty(){ return this.items.length===0; }
      toArray(){ return [...this.items]; }
    }

    // Queue (Urgent events)
    class Queue{
      constructor(){ this.items=[]; }
      enqueue(x){ this.items.push(x); }
      dequeue(){ return this.items.shift(); }
      toArray(){ return [...this.items]; }
    }

    // Global Vars
    let events = new LinkedList();
    let completedStack = new Stack();
    let urgentQueue = new Queue();
    let eventId = 1;

    // Save to localStorage
    function saveEvents() {
      localStorage.setItem("events", JSON.stringify(events.toArray()));
      localStorage.setItem("eventId", eventId);
    }

    // Load from localStorage
    function loadEvents() {
      const storedEvents = JSON.parse(localStorage.getItem("events")) || [];
      eventId = parseInt(localStorage.getItem("eventId")) || 1;
      events = new LinkedList();
      urgentQueue = new Queue();
      completedStack = new Stack();

      storedEvents.forEach(event => {
        events.insert(event);
        if(event.priority === "urgent") urgentQueue.enqueue(event);
        if(event.completed) completedStack.push(event.id);
      });

      renderEvents();
    }

    // Add Event
    function addEvent(){
      const title = document.getElementById('title').value.trim();
      const date = document.getElementById('date').value;
      const priority = document.getElementById('priority').value;
      if(!title||!date){ alert("Fill all fields"); return; }
      const event={id:eventId++, title, date, priority, completed:false};
      events.insert(event);
      if(priority==='urgent') urgentQueue.enqueue(event);
      document.getElementById('title').value='';
      document.getElementById('date').value='';
      renderEvents();
      saveEvents(); // âœ… persist
    }

    // Mark Complete
    function markComplete(id){
      events.markComplete(id);
      completedStack.push(id);
      renderEvents();
      saveEvents();
    }

    // Undo Complete
    function undoComplete(){
      if(completedStack.isEmpty()){ alert("Nothing to undo"); return; }
      const id = completedStack.pop();
      events.undoComplete(id);
      renderEvents();
      saveEvents();
    }

    // Delete Event
    function deleteEvent(id){ 
      events.delete(id); 
      renderEvents();
      saveEvents();
    }

    // Render Events
    function renderEvents(){
      const list=document.getElementById('eventList'); list.innerHTML='';
      events.toArray().forEach(ev=>{
        const div=document.createElement('div');
        div.className='event'+(ev.completed?' completed':'');
        div.innerHTML=`
          <b>${ev.title}</b> | ${ev.date} | ${ev.priority}
          <button onclick="markComplete(${ev.id})">Complete</button>
          <button onclick="deleteEvent(${ev.id})">Delete</button>
        `;
        list.appendChild(div);
      });

      const urgent=document.getElementById('urgentList'); urgent.innerHTML='';
      urgentQueue.toArray().forEach(ev=>{
        urgent.innerHTML+=`<div class="event">${ev.title} | ${ev.date}</div>`;
      });

      const comp=document.getElementById('completedList'); comp.innerHTML='';
      completedStack.toArray().slice().reverse().forEach(id=>{
        const ev=events.toArray().find(e=>e.id===id);
        if(ev) comp.innerHTML+=`<div class="event completed">${ev.title}</div>`;
      });
    }

    // Init
    document.addEventListener("DOMContentLoaded", loadEvents);
  </script>
</body>
</html>
